-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParMplus where
import AbsMplus
import LexMplus
import ErrM

}

%name pStart Start
%name pBlock Block
%name pDeclarations Declarations
%name pDeclaration Declaration
%name pVar_Declaration Var_Declaration
%name pType Type
%name pArray_Dimensions Array_Dimensions
%name pFun_Declaration Fun_Declaration
%name pFun_Block Fun_Block
%name pParam_List Param_List
%name pParameters Parameters
%name pMore_Parameters More_Parameters
%name pBasic_Declaration Basic_Declaration
%name pBasic_Array_Dimensions Basic_Array_Dimensions
%name pProgram_Body Program_Body
%name pFun_Body Fun_Body
%name pProg_Stmts Prog_Stmts
%name pProg_Stmt Prog_Stmt
%name pIdentifier Identifier
%name pExpr Expr
%name pBint_Term Bint_Term
%name pBint_Factor Bint_Factor
%name pCompare_Op Compare_Op
%name pInt_Expr Int_Expr
%name pAddop Addop
%name pInt_Term Int_Term
%name pMulop Mulop
%name pInt_Factor Int_Factor
%name pModifier_List Modifier_List
%name pArguments Arguments
%name pMore_Arguments More_Arguments
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '*' { PT _ (TS _ 3) }
  '+' { PT _ (TS _ 4) }
  ',' { PT _ (TS _ 5) }
  '-' { PT _ (TS _ 6) }
  '/' { PT _ (TS _ 7) }
  ':' { PT _ (TS _ 8) }
  ':=' { PT _ (TS _ 9) }
  ';' { PT _ (TS _ 10) }
  '<' { PT _ (TS _ 11) }
  '=' { PT _ (TS _ 12) }
  '=<' { PT _ (TS _ 13) }
  '>' { PT _ (TS _ 14) }
  '>=' { PT _ (TS _ 15) }
  '[' { PT _ (TS _ 16) }
  ']' { PT _ (TS _ 17) }
  'and' { PT _ (TS _ 18) }
  'begin' { PT _ (TS _ 19) }
  'bool' { PT _ (TS _ 20) }
  'ceil' { PT _ (TS _ 21) }
  'do' { PT _ (TS _ 22) }
  'else' { PT _ (TS _ 23) }
  'end' { PT _ (TS _ 24) }
  'false' { PT _ (TS _ 25) }
  'float' { PT _ (TS _ 26) }
  'floor' { PT _ (TS _ 27) }
  'fun' { PT _ (TS _ 28) }
  'if' { PT _ (TS _ 29) }
  'int' { PT _ (TS _ 30) }
  'not' { PT _ (TS _ 31) }
  'or' { PT _ (TS _ 32) }
  'print' { PT _ (TS _ 33) }
  'read' { PT _ (TS _ 34) }
  'real' { PT _ (TS _ 35) }
  'return' { PT _ (TS _ 36) }
  'size' { PT _ (TS _ 37) }
  'then' { PT _ (TS _ 38) }
  'true' { PT _ (TS _ 39) }
  'var' { PT _ (TS _ 40) }
  'while' { PT _ (TS _ 41) }
  '{' { PT _ (TS _ 42) }
  '}' { PT _ (TS _ 43) }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }

Start :: { Start }
Start : Block { AbsMplus.START $1 }
Block :: { Block }
Block : Declarations Program_Body { AbsMplus.BProg $1 $2 }
Declarations :: { Declarations }
Declarations : Declaration ';' Declarations { AbsMplus.DSemi $1 $3 }
             | {- empty -} { AbsMplus.DEmpty }
Declaration :: { Declaration }
Declaration : Var_Declaration { AbsMplus.DVar $1 }
            | Fun_Declaration { AbsMplus.DFun $1 }
Var_Declaration :: { Var_Declaration }
Var_Declaration : 'var' Ident Array_Dimensions ':' Type { AbsMplus.VD $2 $3 $5 }
Type :: { Type }
Type : 'int' { AbsMplus.TInt }
     | 'real' { AbsMplus.TReal }
     | 'bool' { AbsMplus.TBool }
Array_Dimensions :: { Array_Dimensions }
Array_Dimensions : '[' Expr ']' Array_Dimensions { AbsMplus.ADExpr $2 $4 }
                 | {- empty -} { AbsMplus.ADEmpty }
Fun_Declaration :: { Fun_Declaration }
Fun_Declaration : 'fun' Ident Param_List ':' Type '{' Fun_Block '}' { AbsMplus.FDDec $2 $3 $5 $7 }
Fun_Block :: { Fun_Block }
Fun_Block : Declarations Fun_Body { AbsMplus.FB $1 $2 }
Param_List :: { Param_List }
Param_List : '(' Parameters ')' { AbsMplus.PL $2 }
Parameters :: { Parameters }
Parameters : Basic_Declaration More_Parameters { AbsMplus.PParams $1 $2 }
           | {- empty -} { AbsMplus.PEmpty }
More_Parameters :: { More_Parameters }
More_Parameters : ',' Basic_Declaration More_Parameters { AbsMplus.MPMore $2 $3 }
                | {- empty -} { AbsMplus.MPEmpty }
Basic_Declaration :: { Basic_Declaration }
Basic_Declaration : Ident Basic_Array_Dimensions ':' Type { AbsMplus.BDBasic $1 $2 $4 }
Basic_Array_Dimensions :: { Basic_Array_Dimensions }
Basic_Array_Dimensions : '[' ']' Basic_Array_Dimensions { AbsMplus.BAD $3 }
                       | {- empty -} { AbsMplus.BADEmpty }
Program_Body :: { Program_Body }
Program_Body : 'begin' Prog_Stmts 'end' { AbsMplus.PBBody $2 }
Fun_Body :: { Fun_Body }
Fun_Body : 'begin' Prog_Stmts 'return' Expr ';' 'end' { AbsMplus.FBBody $2 $4 }
Prog_Stmts :: { Prog_Stmts }
Prog_Stmts : Prog_Stmt ';' Prog_Stmts { AbsMplus.PSSemi $1 $3 }
           | {- empty -} { AbsMplus.PSEmpty }
Prog_Stmt :: { Prog_Stmt }
Prog_Stmt : 'if' Expr 'then' Prog_Stmt 'else' Prog_Stmt { AbsMplus.PSITE $2 $4 $6 }
          | 'while' Expr 'do' Prog_Stmt { AbsMplus.PSWhile $2 $4 }
          | 'read' Identifier { AbsMplus.PSRead $2 }
          | Identifier ':=' Expr { AbsMplus.PSAssign $1 $3 }
          | 'print' Expr { AbsMplus.PSPrint $2 }
          | '{' Block '}' { AbsMplus.PSCPar $2 }
Identifier :: { Identifier }
Identifier : Ident Array_Dimensions { AbsMplus.ID $1 $2 }
Expr :: { Expr }
Expr : Expr 'or' Bint_Term { AbsMplus.EOr $1 $3 }
     | Bint_Term { AbsMplus.EBint $1 }
Bint_Term :: { Bint_Term }
Bint_Term : Bint_Term 'and' Bint_Factor { AbsMplus.BTAnd $1 $3 }
          | Bint_Factor { AbsMplus.BTFactor $1 }
Bint_Factor :: { Bint_Factor }
Bint_Factor : 'not' Bint_Factor { AbsMplus.BFNot $2 }
            | Int_Expr Compare_Op Int_Expr { AbsMplus.BFComp $1 $2 $3 }
            | Int_Expr { AbsMplus.BFExpr $1 }
Compare_Op :: { Compare_Op }
Compare_Op : '=' { AbsMplus.COEq }
           | '<' { AbsMplus.COLt }
           | '>' { AbsMplus.COGt }
           | '=<' { AbsMplus.COLe }
           | '>=' { AbsMplus.COGe }
Int_Expr :: { Int_Expr }
Int_Expr : Int_Expr Addop Int_Term { AbsMplus.IEAddop $1 $2 $3 }
         | Int_Term { AbsMplus.IETerm $1 }
Addop :: { Addop }
Addop : '+' { AbsMplus.AAdd } | '-' { AbsMplus.ASub }
Int_Term :: { Int_Term }
Int_Term : Int_Term Mulop Int_Factor { AbsMplus.ITMul $1 $2 $3 }
         | Int_Factor { AbsMplus.ITFactor $1 }
Mulop :: { Mulop }
Mulop : '*' { AbsMplus.MMul } | '/' { AbsMplus.MDiv }
Int_Factor :: { Int_Factor }
Int_Factor : '(' Expr ')' { AbsMplus.IFPar $2 }
           | 'size' '(' Basic_Array_Dimensions ')' { AbsMplus.IFArray $3 }
           | 'float' '(' Expr ')' { AbsMplus.IFFLoat $3 }
           | 'floor' '(' Expr ')' { AbsMplus.IFFloor $3 }
           | 'ceil' '(' Expr ')' { AbsMplus.IFCeil $3 }
           | Ident Modifier_List { AbsMplus.IFModList $1 $2 }
           | Integer { AbsMplus.IFInt $1 }
           | Double { AbsMplus.IFReal $1 }
           | 'true' { AbsMplus.IFTrue }
           | 'false' { AbsMplus.IFFalse }
Modifier_List :: { Modifier_List }
Modifier_List : '(' Arguments ')' { AbsMplus.MLArgs $2 }
              | Array_Dimensions { AbsMplus.MLArray $1 }
Arguments :: { Arguments }
Arguments : Expr More_Arguments { AbsMplus.AExpr $1 $2 }
          | {- empty -} { AbsMplus.AEmpty }
More_Arguments :: { More_Arguments }
More_Arguments : ',' Expr More_Arguments { AbsMplus.MAComma $2 $3 }
               | {- empty -} { AbsMplus.MAEmpty }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

